{
  "hash": "502cfd63e85cda89391e17cc77a7d626",
  "result": {
    "markdown": "---\ntitle:  \"A Weekly Cognitive Psychology Blog: Week Number Twelve Part II\"\nauthor: \"C Miller\"\ndate: \"2023-12-7\"\nimage: \"IMG_1784.JPG\"\n---\n\n\n## 1. Create 100 unique feature vectors\n\n## 2. Create a memory that gets the first 50 items as traces in the memory\n\n### mimics the encoding phase\n\n## 3. Conduct a simulation to mimic a memory test. Presenting new and old items as cues and generating responses from the memory\n\n## 4. Evaluate the models' performance to see if it can discriminate between new and old items\n\n## NOTES\n\n### Anticipated Results\n\n#### Logic\n\n##### Minerva assigns lower values to probes that are \"new\"\n\n### OLD Items\n\n##### mean echo similarity for old items Should be close to 1\n\n##### mean global activation for old items Should be close to 1\n\n### New Items\n\n##### mean echo similarity for new items should be smaller than mean echo cue similarity of OLD items\n\n##### mean global activation for new items should be close to zero\n\n##### Logic: For Old items, mean echo cue similarity with close to value 1, mean global activation close to value of 1 means: each of those items was in the memory system at least one time so should expect at least one item to be strongly activated\n\n##### The echos resemble the cue. The echos are made up of traces in the memory.\n\n##### New traces global activation is low. The items are not exactly the same as the cue for the new item. Mean similarity is not 0, so the cue that the memory has never seen prompts memory to activate traces and the echo resembles pattern in the cue.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_length <- 20  #make random feature vectors for each item\nnum_items <- 100 \n# rows are items\n#columns are features\n```\n:::\n\n\n### A FUNCTION TO GENERATE SETS OF FEATURE VECTORS THAT ARE ALL UNIQUE\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_unique_random_items <- function(num_items = 100, vector_length = 20){\n  items <- t(replicate(num_items,\n                       sample(rep(c(1,-1), vector_length/2\n                                ))))\n  \n  correlation_matrix <- cor(t(items))\nupper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]\n\n  if (length(upper_triangle[upper_triangle == 1]) == 0){\n    return(items)\n  }   else{\n      print(i)\n      generate_unique_random_items(num_items, vector_length)\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#apply a function over a list or vector \n# use replicate for random number generation?\n\n\n\n\n#sample with or without replacement\nitems <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)\n```\n:::\n\n\n## Memory Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define indices for old and new items\nold <- 1:50  # encoding phase \"old\"\nnew <-51:100 # the model did not see this sequence from 51-100 of \"new items\"\n\n\n#put old items into a memory matrix as above\n\n# hold items in a data frame\n\nsimulation_data <- data.frame()\n\n#the memory of the model is a matrix\nmemory <- items[old,] # the first 50 items\n```\n:::\n\n\n#### Get an analysis of how the model responded to new and old items and averages across items.\n\n###### loop over cues\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:100){\n  probe_id <- i\n  probe <- items[probe_id,]\n  \n  #compute similarities\n  \n  similarities <-\nRsemanticLibrarian::cosine_x_to_m(probe, memory)^3\n  \n  #activate traces by weighted similarity\n  \n  activations <- memory * c(similarities)\n  \n  \n  # generate echo and global activation\n  \n  echo <- colSums(activations)\n  global_activation <- sum(similarities)\n  \n  # compare echo to probe\n  echo_cue_similarity <- lsa::cosine(probe, echo)\n  \n  trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity = echo_cue_similarity)\n  \n # per trial when a certain item was the cue how many items were activated what was the global activation\n  simulation_data <- rbind(simulation_data, trial_results)\n}\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}