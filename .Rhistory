library(lsa)
vector_length <- 10  #make random feature vectors for each item
num_items <- 100 # rows are items , columns are features
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- t(replicate(num_items,
sample( rep(c(1,-1), vector_length / 2)
)
))
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
# each row of the matrix codes a memory trace
#matrix items has 100 items in it
probe_id <- 5 #all items in certain number,, then calculate the similarity to "memory"
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^5 #computes similarity between one vector and multiple vectors in a matrix
#activate traces by weighted similarity
activations <- memory * c(similarities)
#calculate the echo response and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
library(devtools)
devtools::install_github("CrumpLab/RsemanticLibrarian")
library(lsa)
vector_length <- 10  #make random feature vectors for each item
num_items <- 100 # rows are items , columns are features
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- t(replicate(num_items,
sample( rep(c(1,-1), vector_length / 2)
)
))
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
# each row of the matrix codes a memory trace
#matrix items has 100 items in it
probe_id <- 5 #all items in certain number,, then calculate the similarity to "memory"
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^5 #computes similarity between one vector and multiple vectors in a matrix
#activate traces by weighted similarity
activations <- memory * c(similarities)
#calculate the echo response and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
lsa::cosine(probe,echo)
global_activation
echo
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id < i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data.trial_results)
}
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id <- i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data.trial_results)
}
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id <- i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity = echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data.trial_results)
}
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id <- i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity = echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data, trial_results)
}
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id <- i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity = echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data, trial_results)
}
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix as above
# hold items in a data frame
simulation_data <- data.frame()
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id <- i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity = echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data, trial_results)
}
View(trial_one)
View(trial_results)
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix as above
# hold items in a data frame
simulation_data <- data.frame()
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id <- i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity = echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data, trial_results)
}
print(simulation_data)
print(simulation_data)
print(simulation_data)
glimpse(simulation_data)
library(tidyverse)
library(lsa)
library(RsemanticLibrarian)
vector_length <- 20  #make random feature vectors for each item
num_items <- 100
# rows are items
#columns are features
generate_unique_random_items <- function(num_items = 100, vector_length = 20){
items <- t(replicate(num_items,
sample(rep(c(1,-1), vector_length/2
))))
correlation_matrix <- cor(t(items))
upper_triangle <- correlation_matrix[upper.tri(correlation_matrix)]
if (length(upper_triangle[upper_triangle == 1]) == 0){
return(items)
}   else{
print(i)
generate_unique_random_items(num_items, vector_length)
}
}
#apply a function over a list or vector
# use replicate for random number generation?
#sample with or without replacement
items <- items <- generate_unique_random_items(num_items = 100, vector_length = 20)
#define indices for old and new items
old <- 1:50  # encoding phase "old"
new <-51:100 # the model did not see this sequence from 51-100 of "new items"
#put old items into a memory matrix as above
# hold items in a data frame
simulation_data <- data.frame()
#the memory of the model is a matrix
memory <- items[old,] # the first 50 items
for(i in 1:100){
probe_id <- i
probe <- items[probe_id,]
#compute similarities
similarities <-
RsemanticLibrarian::cosine_x_to_m(probe, memory)^3
#activate traces by weighted similarity
activations <- memory * c(similarities)
# generate echo and global activation
echo <- colSums(activations)
global_activation <- sum(similarities)
# compare echo to probe
echo_cue_similarity <- lsa::cosine(probe, echo)
trial_results <- data.frame(item = i, global_activation = global_activation, echo_cue_similarity = echo_cue_similarity)
# per trial when a certain item was the cue how many items were activated what was the global activation
simulation_data <- rbind(simulation_data, trial_results)
}
#print(simulation_data)
simulation_data
glimpse(simulation_data)
